#!/bin/bash

### Version 1.0
### Inspired by script pdf-trim-to-djvu.sh (http://gist.github.com/315791)
### PUBLIC DOMAIN

### Settings
# default
DPI=300
treshold=129
usemini=0
usecodjvu=0
ag=0
usepro="-contrast -blur 0x1"
useocr=""
# internal
prog=$0
dpidefault=$DPI
trdefault=$treshold
midefault=$usemini
codefault=$usecodjvu
agdefault=$ag
prodefault=$usepro
ocrdefalut=$useocr

function usage() {
  me=`basename "$prog"`
  cat << END
Usage: $me [options] folder_name

Options:
 -a <0|1|2> aggressivity: 0 is not aggressive, 1 is aggressive, 2 is very aggressive [default: $agdefault]
 -d <int>   resolution in DPI [default: $dpidefault]
 -l <int>   if not 0, will use forced segmentation (with <int> downsampling) [default: $codefault]
 -m <int>   if not 0, will use minidjvu (with <int> dictionary size) instead of cjb2 [default: $midefault]
 -r "str"   if not empty, use cuneiform with given language [default: $ocrdefault]
 -p "str"   process color layer with given ImageMagick options [default: $prodefault]
 -t <int>   if not 0, will use cpaldjvu for all images with number of colors less than <int> [default: $trdefault]
 -h|--help  print this message

END
}

opts=`getopt -l "help" "a:d:h:f:l:m:p:r:t:" "$@"` && eval set -- "$opts"
while true ; do
  case "$1" in
    -h|--help) usage ; exit 0 ;;
    -a) ag=$2 ; shift 2 ;;
    -d) DPI=$2 ; shift 2 ;;
    -l) usecodjvu=$2 ; shift 2 ;;
    -m) usemini=$2 ; shift 2 ;;
    -r) useocr=$2 ; shift 2 ;;
    -p) usepro=$2 ; shift 2 ;;
    -t) treshold=$2 ; shift 2 ;;
    --) shift ; break ;;
  esac
done

### Checks
if [ $# -ne 1 ] ; then
  printf "\nFolder name is required.\n\n"
  usage
  exit 1
fi

if [ ! -d $1 ] ; then
   printf "\n$1 is not a folder.\n\n"
   usage
   exit 1
fi

for f in $1/* ; do
if [ -d $f ] ; then
   printf "\nImage folder should not contain any subfolders.\n\n"
   usage
   exit 1
fi
done

if ! which cpaldjvu >/dev/null ; then
   printf "\nDjVu Libre should be installed.\n\n"
   usage
   exit 1
else
   dv=`cpaldjvu 2>&1| sed -e '2,$d' -e 's/^.*-\([1-9.]*\)$/\1/' -e 's/\.//g'`
fi

if ! which identify >/dev/null ; then
   printf "\nImageMagick should be installed.\n\n"
   usage
   exit 1
fi

if [ -n "$useocr" ] ; then
   if ! which ocrodjvu >/dev/null ; then
      printf "\nFor -r option, ocrodjvu and cuneiform should be installed.\n\n"
      usage
      exit 1
   fi
   if ! which cuneiform >/dev/null ; then
      printf "\nFor -r option, cuneiform and ocrodjvu should be installed.\n\n"
      usage
      exit 1
   fi
fi

### Aggressivity options
case "$ag" in
   0)
      ags="<"
      age=">"
      c44opt=""
      cjb2opt=""
      cpaldjvuopt="-bgwhite"
      minidjvuopt=""
   ;;
   1)
      ags="<<"
      age=">>"
      c44opt="-slice 74+13+10"
      cjb2opt="-clean"
      cpaldjvuopt=""
      minidjvuopt="--clean"
   ;;
   2)
      ags="<<<"
      age=">>>"
      c44opt="-slice 76+15"
      cjb2opt="-lossy"
      cpaldjvuopt=""
      minidjvuopt="--lossy --aggression 200"
   ;;
   *)
   printf "\nAggressivity has only three possible values: 0, 1, or 2.\n\n"
   usage
   exit 1
esac

### Coders functions
function c44coder {
   c44 $c44opt -dpi $DPI $1 $2
   printf "C"
}

# This function does not print because it is called also from inside codjvucoder
function cjb2coder {
   cjb2 $cjb2opt -dpi $DPI $1 $2
}

function cpaldjvucoder {
   cpaldjvu $cpaldjvuopt -dpi $DPI $1 $2
   printf "F"
}

function minidjvucoder {
   printf "$ags""M:"
   minidjvu -d $DPI -p $usemini $minidjvuopt $@
   printf "$bwcount"
}

### Forced segmentation coder
function codjvucoder {
   # folders
   printf "L"
   tmcdir=$tmpdir/codjvu
   mkdir $tmcdir
   # image parameters
   newsize=`identify -format "%[fx:ceil(w/$usecodjvu)]x%[fx:ceil(h/$usecodjvu)]" $1`
   # separate layers from Scan Tailor
   convert -threshold 1 -compress Group4 $1 $tmcdir/fore.pbm
   composite -compose Add \( -negate $tmcdir/fore.pbm \) $1 $tmcdir/bback.ppm
   cd $tmcdir
   printf ":"
   # make BG44 chunk
   convert bback.ppm $usepro -resize $newsize\! back.ppm
   c44 $c44opt back.ppm back.djvu
   djvuextract back.djvu BG44=bg44.cnk >/dev/null 2>&1
   printf "1"
   # make Sjbz chunk
   cjb2coder fore.pbm sjbz.djvu
   djvuextract sjbz.djvu Sjbz=sjbz.cnk >/dev/null 2>&1
   printf "+1"
   if [ $dv -lt 3523 ] ; then
      # make FG44 chunk from background (!)
      convert -size $newsize\! -depth 8 xc:black fore.pgm
      c44 -slice 120 fore.pgm fore.djvu
      djvuextract fore.djvu BG44=fg44.cnk >/dev/null 2>&1
      # make compound DjVu
      djvumake $2 Sjbz=sjbz.cnk FG44=fg44.cnk BG44=bg44.cnk
      else
      # use new ability of djvumake to create FGbz chunk on the fly
      djvumake $2 Sjbz=sjbz.cnk FGbz="#black" BG44=bg44.cnk
   fi
   if [ -n "$useocr" ] ; then
      convert fore.pbm fore.bmp
      cuneiform -l $useocr -f hocr -o fore.hocr fore.bmp >/dev/null 2>&1
      if [ -f fore.hocr ] ; then
        hocr2djvused --page-size `identify -format "%wx%h" fore.pbm ` < fore.hocr 2>/dev/null | djvused -s $2
        printf "+1"
      fi
   fi
   printf "+1"
   cd ..
   rm -rf $tmcdir
}

### Color coder choice
function colorcoder {
if [ $usecodjvu -lt 1 ] ; then
   c44coder $1 $2
else
   codjvucoder $1 $2
fi
}

### General coder and bundler
# convert all pages to pnm: convert
# determine color depth of each page
# if depth <= 1, compress with cjb2 or minidjvu
# if depth > 1 and treshold > 0, count number of unique colors
# if unique colors < 129, compress with cpaldjvu
# if unique colors >= 129, compress with c44 or codjvu
# display progress symbols (B or M for Bitonal, C for TrueColor, L for codjvu layers, F for Palette)
# create bundled DjVu file
function nomini {
( cd $fld &&
  ( # for every page
    for f in * ; do
      of="$tmpdir/$f.pnm"
      convert "$fld/$f" "$of" 2>/dev/null || continue ;
      printf "$ags" && \
      ( # switch between formats
        if [ `identify -format "%q" "$of"` -gt 1 ] ; then
           if [ $treshold -gt 0 ] ; then
              colors=`identify -format "%k" "$of"` && \
              if [ $colors -lt $treshold ] ; then
                 cpaldjvucoder "$of" "$of.djvu"
              else
                 colorcoder "$of" "$of.djvu"
              fi
          else
              colorcoder "$of" "$of.djvu"
          fi
        else
        cjb2coder "$of" "$of.djvu"
        printf "B"
        if [ -n "$useocr" ] ; then
           convert "$of" "$of.bmp"
           cuneiform -l $useocr -f hocr -o "$of.hocr" "$of.bmp" >/dev/null 2>&1
           if [ -f "$of.hocr" ] ; then
              hocr2djvused --page-size `identify -format "%wx%h" $of ` < "$of.hocr" | djvused -s "$of.djvu"
              printf "+"
           fi
        fi
        fi
      ) && \
      rm "$of" && \
      printf "$age"
    done
  ) &&
  cd $tmpdir && \
  djvm -c "$djvu" *.djvu && \
  printf "\nDone.\n"
) && rm -rf "$tmpdir" || (
  printf "Failure\nTemporary directory left: %s\n" $tmpdir
  exit 2
)
}

### Minidjvu-based coder and bundler
# Similar to previous, but instead of cjb2 minidjvu called every time when black and white sequence interrupted with color image, or when sequence ends on black and white file
function mini {
( cd $fld &&
  ( bwcount=0 && \
    pgcount=`ls -1 | wc -l` && \
    bwpages="" && \
    for f in * ; do
      pgcount=$((pgcount-1))
      of="$tmpdir/$f.pnm"
      convert "$fld/$f" "$of" 2>/dev/null || continue ;
        if [ `identify -format "%z" "$of"` -gt 1 ] ; then
           if [ $bwcount -gt 0 ] ; then
              minidjvucoder `echo $bwpages` "$of.1.djvu"
              if [ -n "$useocr" ] ; then
                 ocrodjvu --engine cuneiform --language $useocr --in-place "$of.1.djvu" >/dev/null 2>&1
                 printf "+"
              fi
              bwpages=""
              bwcount=0
              printf "$age"
           fi
           printf "$ags"
           if [ $treshold -gt 0 ] ; then
              colors=`identify -format "%k" "$of"`
              if [ $colors -lt $treshold ] ; then
                 cpaldjvucoder "$of" "$of.2.djvu"
              else
                 colorcoder "$of" "$of.2.djvu"
              fi
           else
              colorcoder "$of" "$of.2.djvu"
           fi
           printf "$age"
        else
           bwpages="$bwpages $of"
           bwcount=$((bwcount+1))
        fi
          if [[ $pgcount -eq 0 && $bwcount -gt 0 ]] ; then 
              minidjvucoder `echo $bwpages` "$of.1.djvu"
              if [ -n "$useocr" ] ; then
                 ocrodjvu --engine cuneiform --language $useocr --in-place "$of.1.djvu" >/dev/null 2>&1
                 printf "+"
              fi
              bwpages=""
              bwcount=0
              printf "$age"
           fi
    done
  ) &&
  cd $tmpdir && \
  djvm -c "$djvu" *.djvu && \
  printf "\nDone.\n"
) && rm -rf "$tmpdir" || (
  printf "Failure\nTemporary directory left: %s\n" $tmpdir
  exit 2
)
}

# Absolute paths to input folder and output DjVu files
fld="`pwd`/$1"
djvu="`pwd`/$1.djvu"

### START!
if [ $usemini -lt 1 ] ; then
   tmpdir=`mktemp -d /tmp/pagesXXXXX`
   nomini
else
   if ! which minidjvu >/dev/null ; then
      printf "\nFor -m option, minidjvu is required.\n\n"
      usage
      exit 1
   fi
   tmpdir=`mktemp -d /tmp/pagesXXXXX`
   mini
fi
